## Promise基本用法



## Promise凭什么解决了“回调地狱”

主要有三个原因：

1. then链式调用，实现回调函数**延迟绑定**

   通过then的链式调用，我们可以在定义了要同步执行的代码后再通过then执行其定义的回调函数。

   比如：

   

2. **返回值穿透**

   通过promise中then的调用，可以将其返回值作为一个新的promise，在之后的then中调用其上一个then的返回值，比如我们常用的fetch：

   ```js
   fetch('http://example.com/api').then(res=>res.json()).then(jsonRes=>{console.log(jsonRes)})
   ```

   在上面的逻辑中，我们在第一个then里返回response响应的json格式的数据，以供下一个then调用，第二个then中的jsonRes已经是第一个res.json()的结果了。

3. **错误冒泡**处理

   在以往的回调函数中，我们往往需要同时定义success和error两种情况，而对于多个调用，这样会让开发变得非常的麻烦，要编写很多的错误处理，而在promise中，所有的错误都会冒泡到catch之中，我们可以在只编写一个回调事件用于处理出错的catch事件。

## Promise的then为什么是一个微任务

在JavaScript回调函数的调用有三种方式：

> 1. 同步调用，在回调函数拿到结果前不执行任何其他代码。
> 2. 异步调用，作为宏任务插入到宏任务队列的队尾，在宏任务队列中按次序执行。
> 3. 异步调用，作为微任务插入到当前宏任务的微任务队列中，即在执行当前宏任务的最后执行微任务队列。

显然，如果把promise的then作为第一种方式，将会**导致cpu资源的浪费**，**出现**同步的**阻塞问题**，这是很浪费计算机宝贵资源的（实际上就是同步异步本身的性能差异），与此同时还会有一个问题，那就是将其定义成同步任务，**无法实现延迟绑定回调函数**的效果

延迟绑定：也就是在定义好要执行的同步函数之后，再从then中传入回调函数。

而异步调用，若是作为宏任务，**如果宏任务队列很长**，要执行的代码很多，就**会出现严重的延迟**，而对于大部分的场景，我们都是希望能尽早完成回调函数的调用的。

所以Promise的then自然而然地成为了一个微任务，既使用了异步回调**保证效率**，也**保证**了回调函数调用的**实时性**。

## Promise手写

